#!/usr/bin/env python3
"""kdiff — compare Kubernetes resources between two clusters
This is the Python replacement for the previous Bash CLI.
Usage: bin/kdiff -c1 CONTEXT1 -c2 CONTEXT2 [options]
"""
from __future__ import annotations
import argparse
import json
import shutil
import subprocess
import sys
from pathlib import Path
from datetime import datetime, timezone
import importlib.util

ROOT = Path(__file__).resolve().parent.parent
LIB = ROOT / 'lib'

# Default resources
RESOURCES = [
    'deployment', 'statefulset', 'daemonset', 'configmap', 'secret',
    'persistentvolumeclaim', 'serviceaccount', 'role', 'rolebinding', 'horizontalpodautoscaler',
    'cronjob', 'job'
]
VOLATILE_RESOURCES = ['replicaset', 'pod']
SERVICE_INGRESS_RESOURCES = ['service', 'ingress']

# All supported resources for reference
ALL_SUPPORTED_RESOURCES = RESOURCES + VOLATILE_RESOURCES + SERVICE_INGRESS_RESOURCES

GREEN = '\033[0;32m'
YELLOW = '\033[0;33m'
RED = '\033[0;31m'
RESET = '\033[0m'


def timestamp():
    return datetime.now(timezone.utc).strftime('%Y%m%dT%H%M%SZ')


def check_deps():
    if not shutil.which('kubectl'):
        print("Errore: 'kubectl' non trovato. Installalo e riprova.", file=sys.stderr)
        sys.exit(2)


def cleanup_old_outputs(base_dir: Path, keep_last: int = 3):
    """Keep only the last N timestamped output directories."""
    if not base_dir.exists():
        return
    # Get all timestamped subdirectories (format: YYYYMMDDTHHMMSSZ)
    subdirs = [d for d in base_dir.iterdir() if d.is_dir() and d.name[0].isdigit()]
    if len(subdirs) <= keep_last:
        return
    # Sort by name (timestamp) and remove oldest
    subdirs.sort()
    for old_dir in subdirs[:-keep_last]:
        try:
            shutil.rmtree(old_dir)
            print(f"Removed old output: {old_dir.name}")
        except Exception as e:
            print(f"Warning: Could not remove {old_dir}: {e}", file=sys.stderr)


# dynamic import helper to load normalize.normalize
def load_normalize_func():
    spec = importlib.util.spec_from_file_location('normalize', str(LIB / 'normalize.py'))
    mod = importlib.util.module_from_spec(spec)
    spec.loader.exec_module(mod)  # type: ignore
    return getattr(mod, 'normalize')


def fetch_resources(context: str, outdir: Path, resources: list[str], namespace: str | None, show_metadata: bool = False):
    outdir.mkdir(parents=True, exist_ok=True)
    norm = load_normalize_func()

    for kind in resources:
        print(f"[{context}] Fetching {kind}...")
        cmd = ['kubectl', '--context', context]
        if namespace:
            cmd += ['-n', namespace, 'get', kind, '-o', 'json']
        else:
            cmd += ['get', kind, '--all-namespaces', '-o', 'json']

        try:
            proc = subprocess.run(cmd, check=False, capture_output=True, text=True)
            if proc.returncode != 0:
                print(f"[{context}] Warning: 'kubectl' returned non-zero for {kind} (continuo).", file=sys.stderr)
                continue
            data = json.loads(proc.stdout) if proc.stdout.strip() else {}
            items = data.get('items', [])
            if not items:
                print(f"[{context}] Nessun oggetto {kind}.")
                continue
            for item in items:
                name = item.get('metadata', {}).get('name')
                ns = item.get('metadata', {}).get('namespace')
                if ns:
                    fname = f"{kind}__{ns}__{name}.json"
                else:
                    fname = f"{kind}__{name}.json"
                path = outdir / fname
                # pass show-metadata flag to the normalizer
                n = norm(item, keep_metadata=bool(show_metadata))
                path.write_text(json.dumps(n, sort_keys=True, indent=2, ensure_ascii=False) + "\n", encoding='utf-8')
        except Exception as e:
            print(f"[{context}] Errore fetching {kind}: {e}", file=sys.stderr)
            continue


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('-c1', required=True)
    parser.add_argument('-c2', required=True)
    parser.add_argument('-r')
    parser.add_argument('-n')
    parser.add_argument('-o')
    parser.add_argument('-f', '--format', dest='format', default='text')
    parser.add_argument('--include-volatile', action='store_true')
    parser.add_argument('--include-services-ingress', action='store_true', help='Include service and ingress resources in comparison')
    parser.add_argument('--include-resource-types', help=f'Comma-separated list of resource types to include in comparison (overrides defaults). Use "all" to include all supported types. Supported: {", ".join(ALL_SUPPORTED_RESOURCES)}')
    parser.add_argument('--exclude-resources', help=f'Comma-separated list of resource types to exclude from comparison. Supported resources: {", ".join(ALL_SUPPORTED_RESOURCES)}')
    parser.add_argument('--show-metadata', action='store_true', help='Keep metadata.labels and annotations in normalized output')
    args = parser.parse_args()

    resources = RESOURCES.copy()
    if args.r:
        resources = [r.strip() for r in args.r.split(',') if r.strip()]
    
    # Handle explicit include list (overrides defaults)
    if args.include_resource_types:
        if args.include_resource_types.lower() == 'all':
            resources = ALL_SUPPORTED_RESOURCES.copy()
        else:
            resources = [r.strip() for r in args.include_resource_types.split(',') if r.strip()]
            # Validate that all specified resources are supported
            unsupported = [r for r in resources if r.lower() not in [x.lower() for x in ALL_SUPPORTED_RESOURCES]]
            if unsupported:
                print(f"Error: Unsupported resource types: {', '.join(unsupported)}", file=sys.stderr)
                print(f"Supported types: {', '.join(ALL_SUPPORTED_RESOURCES)}", file=sys.stderr)
                sys.exit(2)
    else:
        # Use default behavior with optional additions
        if args.include_volatile:
            resources += VOLATILE_RESOURCES
        if args.include_services_ingress:
            resources += SERVICE_INGRESS_RESOURCES
    
    # Exclude specific resources if requested
    if args.exclude_resources:
        exclude_list = [r.strip().lower() for r in args.exclude_resources.split(',') if r.strip()]
        resources = [r for r in resources if r.lower() not in exclude_list]
        if not resources:
            print("Error: All resources excluded. Nothing to compare.", file=sys.stderr)
            sys.exit(2)

    # Cleanup old outputs before creating new one
    if not args.o:
        cleanup_old_outputs(Path('./kdiff_output'), keep_last=3)
    
    outdir = Path(args.o) if args.o else Path('./kdiff_output') / timestamp()
    # Use actual cluster names instead of generic cluster1/cluster2
    dir1 = outdir / args.c1
    dir2 = outdir / args.c2
    diffs = outdir / 'diffs'
    json_out = outdir / 'summary.json'

    check_deps()

    print(f"Fetching resources from {args.c1}...")
    fetch_resources(args.c1, dir1, resources, args.n, args.show_metadata)

    print(f"Fetching resources from {args.c2}...")
    fetch_resources(args.c2, dir2, resources, args.n, args.show_metadata)

    print("Confronto...")
    # call compare.py
    rc = subprocess.run(['python3', str(LIB / 'compare.py'), str(dir1), str(dir2), str(diffs), '--json-out', str(json_out)]).returncode

    if rc == 0:
        print(f"\n{GREEN}✅ I cluster sono uguali per le risorse verificate.{RESET}")
        sys.exit(0)
    else:
        print(f"\n{YELLOW}⚠️ Sono state trovate differenze. Vedi {diffs} per i dettagli.{RESET}", file=sys.stderr)
        print(f"Sintesi JSON: {json_out}")
        if args.format == 'text':
            subprocess.run(['python3', str(LIB / 'report.py'), str(json_out), str(diffs), '--cluster1', args.c1, '--cluster2', args.c2])
        # Always generate markdown/html reports for easier sharing
        subprocess.run(['python3', str(LIB / 'report_md.py'), str(json_out), str(diffs), str(outdir), '--cluster1', args.c1, '--cluster2', args.c2])
        # Generate detailed field-level diff report
        subprocess.run(['python3', str(LIB / 'diff_details.py'), str(outdir), '--cluster1', args.c1, '--cluster2', args.c2])
        sys.exit(1)


if __name__ == '__main__':
    main()

