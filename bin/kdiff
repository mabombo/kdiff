#!/usr/bin/env python3
"""kdiff ‚Äî compare Kubernetes resources between two clusters
This is the Python replacement for the previous Bash CLI.
Usage: bin/kdiff -c1 CONTEXT1 -c2 CONTEXT2 [options]
"""
from __future__ import annotations
import argparse
import json
import os
import shutil
import subprocess
import sys
from pathlib import Path
from datetime import datetime
import importlib.util

ROOT = Path(__file__).resolve().parent.parent
LIB = ROOT / 'lib'

# Default resources
RESOURCES = [
    'deployment', 'statefulset', 'daemonset', 'configmap', 'secret',
    'persistentvolumeclaim', 'serviceaccount', 'role', 'rolebinding', 'horizontalpodautoscaler',
    'cronjob', 'job'
]
VOLATILE_RESOURCES = ['replicaset', 'pod']
SERVICE_INGRESS_RESOURCES = ['service', 'ingress']

# All supported resources for reference
ALL_SUPPORTED_RESOURCES = RESOURCES + VOLATILE_RESOURCES + SERVICE_INGRESS_RESOURCES

GREEN = '\033[0;32m'
YELLOW = '\033[0;33m'
RED = '\033[0;31m'
RESET = '\033[0m'


def check_deps():
    if not shutil.which('kubectl'):
        print("Error: 'kubectl' not found. Install it and try again.", file=sys.stderr)
        sys.exit(2)


def cleanup_output_dir(outdir: Path):
    """Clean output directory if it already exists."""
    if outdir.exists():
        try:
            shutil.rmtree(outdir)
            print(f"Cleaning existing output directory: {outdir}")
        except Exception as e:
            print(f"Warning: Unable to clean {outdir}: {e}", file=sys.stderr)


def is_running_in_docker() -> bool:
    """Detect if the script is running inside a Docker container."""
    # Check for .dockerenv file (most reliable)
    if os.path.exists('/.dockerenv'):
        return True
    
    # Check cgroup for docker
    try:
        with open('/proc/1/cgroup', 'rt') as f:
            return 'docker' in f.read()
    except Exception:
        pass
    
    return False


def open_html_in_browser(html_path: Path) -> bool:
    """Try to open HTML file in the default browser.
    Returns True if successful, False otherwise.
    Skips opening if running in Docker container or KDIFF_NO_BROWSER is set.
    """
    # Skip browser opening if explicitly disabled
    if os.getenv('KDIFF_NO_BROWSER'):
        return False
    
    # Skip browser opening in Docker environment
    if is_running_in_docker():
        return False
    
    import platform
    try:
        system = platform.system()
        if system == 'Darwin':  # macOS
            subprocess.run(['open', str(html_path)], check=True)
        elif system == 'Linux':
            subprocess.run(['xdg-open', str(html_path)], check=True)
        elif system == 'Windows':
            subprocess.run(['start', str(html_path)], shell=True, check=True)
        else:
            return False
        return True
    except Exception:
        return False


# dynamic import helper to load normalize.normalize
def load_normalize_func():
    spec = importlib.util.spec_from_file_location('normalize', str(LIB / 'normalize.py'))
    mod = importlib.util.module_from_spec(spec)
    spec.loader.exec_module(mod)  # type: ignore
    return getattr(mod, 'normalize')


def discover_custom_resources(context: str, namespace: str | None = None, groups: list[str] | None = None) -> list[str]:
    """Discover Custom Resources (CR) in the cluster.
    
    Args:
        context: Kubernetes context name
        namespace: Optional namespace to filter (for namespaced resources)
        groups: Optional list of API groups to filter (e.g., ['istio.io', 'cert-manager.io'])
    
    Returns:
        List of CR types in format 'plural.group.domain' (e.g., 'virtualservices.networking.istio.io')
    """
    try:
        # Get all API resources
        cmd = ['kubectl', '--context', context, 'api-resources', '--verbs=list', '-o', 'name']
        if namespace:
            cmd.insert(3, '--namespaced=true')
        
        result = subprocess.run(cmd, capture_output=True, text=True, check=False)
        if result.returncode != 0:
            return []
        
        all_resources = [r.strip() for r in result.stdout.strip().split('\n') if r.strip()]
        
        # Filter for Custom Resources (have dots in name, indicating API group)
        # Exclude native K8s resources
        native_prefixes = [
            'deployments', 'pods', 'services', 'configmaps', 'secrets', 'namespaces',
            'nodes', 'persistentvolumes', 'persistentvolumeclaims', 'serviceaccounts',
            'roles', 'rolebindings', 'clusterroles', 'clusterrolebindings',
            'ingresses', 'networkpolicies', 'replicasets', 'statefulsets', 'daemonsets',
            'jobs', 'cronjobs', 'horizontalpodautoscalers', 'endpoints', 'events',
            'limitranges', 'resourcequotas', 'componentstatuses', 'replicationcontrollers'
        ]
        
        custom_resources = []
        for resource in all_resources:
            # CR must have a dot (API group) and not be a native resource
            if '.' in resource:
                resource_name = resource.split('.')[0]
                if resource_name not in native_prefixes:
                    # If groups filter is specified, check if resource belongs to those groups
                    if groups:
                        resource_group = '.'.join(resource.split('.')[1:])  # e.g., 'networking.istio.io'
                        if any(resource_group.endswith(g) or resource_group == g for g in groups):
                            custom_resources.append(resource)
                    else:
                        custom_resources.append(resource)
        
        return custom_resources
    except Exception as e:
        print(f"Warning: Failed to discover custom resources in '{context}': {e}", file=sys.stderr)
        return []


def fetch_resources(context: str, outdir: Path, resources: list[str], namespaces: list[str] | None, show_metadata: bool = False):
    outdir.mkdir(parents=True, exist_ok=True)
    norm = load_normalize_func()
    has_errors = False
    resource_count = 0

    for kind in resources:
        print(f"[{context}] Fetching {kind}...")
        cmd = ['kubectl', '--context', context]
        
        if namespaces:
            # Fetch from multiple namespaces and merge results
            all_items = []
            for ns in namespaces:
                ns_cmd = cmd + ['-n', ns, 'get', kind, '-o', 'json']
                try:
                    ns_proc = subprocess.run(ns_cmd, check=False, capture_output=True, text=True)
                    if ns_proc.returncode == 0:
                        data = json.loads(ns_proc.stdout)
                        if 'items' in data:
                            all_items.extend(data['items'])
                except Exception:
                    pass
            # Create merged response
            proc = type('obj', (object,), {
                'returncode': 0,
                'stdout': json.dumps({'items': all_items}),
                'stderr': ''
            })()
        else:
            cmd += ['get', kind, '--all-namespaces', '-o', 'json']
            proc = subprocess.run(cmd, check=False, capture_output=True, text=True)

        try:
            if proc.returncode != 0:
                stderr = proc.stderr.strip()
                
                # CRITICAL connectivity errors (terminate execution)
                if 'does not exist' in stderr:
                    print(f"\n{RED}‚úó CRITICAL ERROR:{RESET} Context '{context}' does not exist in kubeconfig", file=sys.stderr)
                    print(f"{YELLOW}üí° Suggestion:{RESET} Verify with 'kubectl config get-contexts'", file=sys.stderr)
                    sys.exit(2)
                elif 'no such host' in stderr or 'dial tcp' in stderr:
                    print(f"\n{RED}‚úó CRITICAL ERROR:{RESET} Unable to connect to cluster '{context}'", file=sys.stderr)
                    print(f"{YELLOW}üí° Possible causes:{RESET}", file=sys.stderr)
                    print(f"  - Cluster unreachable (DNS, network, firewall)", file=sys.stderr)
                    print(f"  - VPN not active", file=sys.stderr)
                    print(f"  - API server unavailable", file=sys.stderr)
                    if 'no such host' in stderr:
                        # Extract hostname from error
                        import re
                        hostname_match = re.search(r'lookup ([^:]+):', stderr)
                        if hostname_match:
                            print(f"  - Unresolvable hostname: {hostname_match.group(1)}", file=sys.stderr)
                    sys.exit(2)
                elif 'timeout' in stderr.lower() or 'timed out' in stderr.lower():
                    print(f"\n{RED}‚úó CRITICAL ERROR:{RESET} Connection timeout to cluster '{context}'", file=sys.stderr)
                    print(f"{YELLOW}üí° Suggestion:{RESET} Check network connectivity and that cluster is active", file=sys.stderr)
                    sys.exit(2)
                
                # NON-critical errors (permissions, empty resources, etc)
                elif 'Forbidden' in stderr or 'forbidden' in stderr:
                    print(f"[{context}] {RED}‚úó{RESET} Insufficient permissions for {kind} at cluster level.", file=sys.stderr)
                    if not namespace:
                        print(f"[{context}] {YELLOW}üí° Suggestion:{RESET} Specify a namespace with -n <namespace>", file=sys.stderr)
                    has_errors = True
                elif stderr:
                    print(f"[{context}] {YELLOW}‚ö†{RESET}  kubectl error per {kind}: {stderr[:100]}", file=sys.stderr)
                    has_errors = True
                else:
                    print(f"[{context}] {YELLOW}‚ö†{RESET}  kubectl returned non-zero for {kind} (exit code {proc.returncode})", file=sys.stderr)
                    has_errors = True
                continue
            data = json.loads(proc.stdout) if proc.stdout.strip() else {}
            items = data.get('items', [])
            if not items:
                print(f"[{context}] Nessun oggetto {kind}.")
                continue
            for item in items:
                name = item.get('metadata', {}).get('name')
                ns = item.get('metadata', {}).get('namespace')
                if ns:
                    fname = f"{kind}__{ns}__{name}.json"
                else:
                    fname = f"{kind}__{name}.json"
                path = outdir / fname
                resource_count += 1
                # pass show-metadata flag to the normalizer
                n = norm(item, keep_metadata=bool(show_metadata))
                path.write_text(json.dumps(n, sort_keys=True, indent=2, ensure_ascii=False) + "\n", encoding='utf-8')
        except Exception as e:
            print(f"[{context}] Errore fetching {kind}: {e}", file=sys.stderr)
            continue
    
    # Final check: if no resources retrieved, it could be a serious problem
    if resource_count == 0 and has_errors:
        print(f"\n{RED}‚úó WARNING:{RESET} No resources retrieved from '{context}' due to errors.", file=sys.stderr)
        print(f"{YELLOW}üí° Suggestion:{RESET} Resolve errors above before continuing.", file=sys.stderr)
        return False
    
    return True


def main():
    parser = argparse.ArgumentParser(
        description='kdiff ‚Äî Compare Kubernetes resources between two clusters',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog='''
Examples:
  # Compare all default resources between two clusters
  kdiff -c1 prod-cluster -c2 staging-cluster

  # Compare only deployments and configmaps in a specific namespace
  kdiff -c1 prod-cluster -c2 staging-cluster -r deployment,configmap -n my-namespace

  # Compare resources across multiple namespaces
  kdiff -c1 prod-cluster -c2 staging-cluster -n connect,default,kube-system

  # Compare all supported resource types (including volatile resources)
  kdiff -c1 prod-cluster -c2 staging-cluster --include-resource-types all

  # Compare with custom output directory
  kdiff -c1 prod-cluster -c2 staging-cluster -o /tmp/my-diff-output

  # Compare and generate only JSON output (skip console report)
  kdiff -c1 prod-cluster -c2 staging-cluster -f json

  # Compare including pods and replicasets (volatile resources)
  kdiff -c1 prod-cluster -c2 staging-cluster --include-volatile

  # Compare keeping metadata labels and annotations
  kdiff -c1 prod-cluster -c2 staging-cluster --show-metadata

  # Compare excluding secrets and configmaps
  kdiff -c1 prod-cluster -c2 staging-cluster --exclude-resources secret,configmap

  # Compare including all Custom Resources (auto-discovery)
  kdiff -c1 prod-cluster -c2 staging-cluster -n my-namespace --include-cr

  # Compare including only specific Custom Resource groups
  kdiff -c1 prod-cluster -c2 staging-cluster -n my-namespace --include-cr istio.io,cert-manager.io

Default resources compared:
  deployment, statefulset, daemonset, configmap, secret, persistentvolumeclaim,
  serviceaccount, role, rolebinding, horizontalpodautoscaler, cronjob, job
        ''')
    
    parser.add_argument('-c1', 
                       required=True, 
                       metavar='CONTEXT1',
                       help='First Kubernetes context name (e.g., prod-cluster). Use "kubectl config get-contexts" to see available contexts')
    
    parser.add_argument('-c2', 
                       required=True,
                       metavar='CONTEXT2', 
                       help='Second Kubernetes context name to compare against (e.g., staging-cluster)')
    
    parser.add_argument('-r',
                       metavar='RESOURCES',
                       help='Comma-separated list of resource types to compare (e.g., deployment,configmap,secret). If not specified, compares default resources. See examples below for details')
    
    parser.add_argument('-n',
                       metavar='NAMESPACE',
                       help='Kubernetes namespace(s) to filter resources. Use comma-separated values for multiple namespaces (e.g., "connect,default"). If not specified, compares resources across all namespaces (--all-namespaces)')
    
    parser.add_argument('-o',
                       metavar='OUTPUT_DIR',
                       help='Output directory for comparison results (default: ./kdiff_output/latest). Directory will be cleaned if it already exists')
    
    parser.add_argument('-f', '--format',
                       dest='format',
                       default='text',
                       metavar='FORMAT',
                       choices=['text', 'json'],
                       help='Output format for console report: "text" (default, colorized console output) or "json" (only JSON files, no console report)')
    
    parser.add_argument('--include-volatile',
                       action='store_true',
                       help='Include volatile resources in comparison (pod, replicaset). By default these are excluded as they change frequently')
    
    parser.add_argument('--include-services-ingress', 
                       action='store_true', 
                       help='Include service and ingress resources in comparison')
    
    parser.add_argument('--include-resource-types',
                       metavar='TYPES',
                       help=f'Comma-separated list of resource types to include in comparison (overrides defaults). Use "all" to include all supported types. Supported: {", ".join(ALL_SUPPORTED_RESOURCES)}')
    
    parser.add_argument('--exclude-resources',
                       metavar='TYPES',
                       help=f'Comma-separated list of resource types to exclude from comparison. Supported resources: {", ".join(ALL_SUPPORTED_RESOURCES)}')
    
    parser.add_argument('--include-cr',
                       nargs='?',
                       const='__ALL__',
                       metavar='GROUPS',
                       help='Include Custom Resources (CR) in comparison. Without arguments, auto-discovers all CRs. With arguments, specify API groups comma-separated (e.g., "istio.io,cert-manager.io")')
    
    parser.add_argument('--show-metadata',
                       action='store_true',
                       help='Keep metadata.labels and annotations in normalized output. By default, metadata is stripped to focus on actual configuration differences')
    
    args = parser.parse_args()

    resources = RESOURCES.copy()
    if args.r:
        resources = [r.strip() for r in args.r.split(',') if r.strip()]
    
    # Handle explicit include list (overrides defaults)
    if args.include_resource_types:
        if args.include_resource_types.lower() == 'all':
            resources = ALL_SUPPORTED_RESOURCES.copy()
        else:
            resources = [r.strip() for r in args.include_resource_types.split(',') if r.strip()]
            # Validate that all specified resources are supported
            unsupported = [r for r in resources if r.lower() not in [x.lower() for x in ALL_SUPPORTED_RESOURCES]]
            if unsupported:
                print(f"Error: Unsupported resource types: {', '.join(unsupported)}", file=sys.stderr)
                print(f"Supported types: {', '.join(ALL_SUPPORTED_RESOURCES)}", file=sys.stderr)
                sys.exit(2)
    else:
        # Use default behavior with optional additions
        if args.include_volatile:
            resources += VOLATILE_RESOURCES
        if args.include_services_ingress:
            resources += SERVICE_INGRESS_RESOURCES
    
    # Exclude specific resources if requested
    if args.exclude_resources:
        exclude_list = [r.strip().lower() for r in args.exclude_resources.split(',') if r.strip()]
        resources = [r for r in resources if r.lower() not in exclude_list]
        if not resources and not args.include_cr:
            print("Error: All resources excluded. Nothing to compare.", file=sys.stderr)
            sys.exit(2)
    
    # Handle Custom Resources (CR)
    custom_resources = []
    if args.include_cr is not None:
        cr_groups = None
        if args.include_cr != '__ALL__':
            # User specified specific groups
            cr_groups = [g.strip() for g in args.include_cr.split(',') if g.strip()]
            print(f"Discovering Custom Resources for groups: {', '.join(cr_groups)}")
        else:
            print("Auto-discovering all Custom Resources...")
        
        # Discover CRs from both clusters (union)
        cr_set = set()
        for ctx in [args.c1, args.c2]:
            discovered = discover_custom_resources(ctx, args.n, cr_groups)
            cr_set.update(discovered)
        
        custom_resources = sorted(list(cr_set))
        
        if custom_resources:
            print(f"Found {len(custom_resources)} Custom Resource type(s): {', '.join(custom_resources[:5])}{' ...' if len(custom_resources) > 5 else ''}")
        else:
            print("No Custom Resources found matching criteria")
    
    # Combine native resources and custom resources
    all_resources_to_fetch = resources + custom_resources
    
    if not all_resources_to_fetch:
        print("Error: No resources to compare.", file=sys.stderr)
        sys.exit(2)

    # Usa sempre la stessa directory per output (latest)
    outdir = Path(args.o) if args.o else Path('./kdiff_output/latest')
    
    # Pulisce la directory se esiste gi√†
    cleanup_output_dir(outdir)
    
    # Use actual cluster names instead of generic cluster1/cluster2
    dir1 = outdir / args.c1
    dir2 = outdir / args.c2
    diffs = outdir / 'diffs'
    json_out = outdir / 'summary.json'

    check_deps()

    # Parse namespaces if provided (comma-separated)
    namespaces = None
    if args.n:
        namespaces = [ns.strip() for ns in args.n.split(',')]
        print(f"Targeting namespace(s): {', '.join(namespaces)}")

    print(f"Fetching resources from {args.c1}...")
    success1 = fetch_resources(args.c1, dir1, all_resources_to_fetch, namespaces, args.show_metadata)

    print(f"Fetching resources from {args.c2}...")
    success2 = fetch_resources(args.c2, dir2, all_resources_to_fetch, namespaces, args.show_metadata)
    
    # If both clusters failed fetch, exit
    if not success1 and not success2:
        print(f"\n{RED}‚úó FATAL ERROR:{RESET} Unable to retrieve resources from both clusters.", file=sys.stderr)
        sys.exit(2)
    elif not success1:
        print(f"\n{RED}‚úó ERROR:{RESET} Unable to retrieve resources from '{args.c1}'.", file=sys.stderr)
        print(f"{YELLOW}Continuing anyway with available resources from '{args.c2}'...{RESET}", file=sys.stderr)
    elif not success2:
        print(f"\n{RED}‚úó ERROR:{RESET} Unable to retrieve resources from '{args.c2}'.", file=sys.stderr)
        print(f"{YELLOW}Continuing anyway with available resources from '{args.c1}'...{RESET}", file=sys.stderr)

    print("Comparing...")
    # call compare.py
    rc = subprocess.run(['python3', str(LIB / 'compare.py'), str(dir1), str(dir2), str(diffs), '--json-out', str(json_out)]).returncode

    # Report HTML interattivo dettagliato - SEMPRE generato (anche con 0 differenze)
    subprocess.run(['python3', str(LIB / 'diff_details.py'), str(outdir), '--cluster1', args.c1, '--cluster2', args.c2])
    
    # Path to the HTML report
    html_report = outdir / 'diff-details.html'

    if rc == 0:
        print(f"\n{GREEN}‚úÖ Clusters are equal for the verified resources.{RESET}")
        print(f"üìä HTML Report: {html_report}")
        
        # Try to open HTML report in browser
        if open_html_in_browser(html_report):
            print(f"{GREEN}üåê Opening report in browser...{RESET}")
        else:
            # Show OS-specific command to open the file
            import platform
            system = platform.system()
            
            # Use the path as-is (it's already relative to output dir)
            file_path = html_report
            
            if system == 'Darwin':  # macOS
                cmd = f"open {file_path}"
            elif system == 'Linux':
                cmd = f"xdg-open {file_path}"
            elif system == 'Windows':
                cmd = f"start {file_path}"
            else:
                cmd = f"<browser> {file_path}"
            print(f"{YELLOW}üí° Open manually: {cmd}{RESET}")
        
        sys.exit(0)
    else:
        print(f"\n{YELLOW}‚ö†Ô∏è Differences found. See {diffs} for details.{RESET}", file=sys.stderr)
        print(f"JSON Summary: {json_out}")
        
        # Report console (solo se richiesto formato text)
        if args.format == 'text':
            subprocess.run(['python3', str(LIB / 'report.py'), str(json_out), str(diffs), '--cluster1', args.c1, '--cluster2', args.c2])
        
        # Report Markdown/HTML semplici (commentati - usare diff-details invece)
        # subprocess.run(['python3', str(LIB / 'report_md.py'), str(json_out), str(diffs), str(outdir), '--cluster1', args.c1, '--cluster2', args.c2])
        
        print(f"üìä HTML Report: {html_report}")
        
        # Try to open HTML report in browser
        if open_html_in_browser(html_report):
            print(f"{GREEN}üåê Opening report in browser...{RESET}")
        else:
            # Show OS-specific command to open the file
            import platform
            system = platform.system()
            
            # Use the path as-is (it's already relative to output dir)
            file_path = html_report
            
            if system == 'Darwin':  # macOS
                cmd = f"open {file_path}"
            elif system == 'Linux':
                cmd = f"xdg-open {file_path}"
            elif system == 'Windows':
                cmd = f"start {file_path}"
            else:
                cmd = f"<browser> {file_path}"
            print(f"{YELLOW}üí° Open manually: {cmd}{RESET}")
        
        sys.exit(1)


if __name__ == '__main__':
    main()

